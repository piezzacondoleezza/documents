**Стандартное представление вещественных чисел в языках**

Сейчас практически везде используется стандарт IEEE(https://en.wikipedia.org/wiki/IEEE_754) или какая-то его вариация, или еще что-то в этом духе, в данной статье про него подробно рассказывается, распишем как это выглядит более кратко, по каким-то базовым постулатам:
*это общая часть какая-то по-видимому будет*


**Ремарочка**
Сделаю небольшую ремарку, что в данном пересказе хотелось бы упомянть скорее о внутренних проблемах и интересных рассуждениях, а не о строении напрямую. Ибо практически каждый, кто ознакомлен с языками программирования - знаком со строением вещественных чисел в виде экспоненты, мантиссы и знака, знает о денормализованных числах и нуле, и прочее. 


**Представление и проблемы вещественных чисел в различных языках**

Зачастую, политика относительно чисел с плавающей точкой неочевидна, ибо авторы стандарта языка не регламентируют, какой инвариант сохраняется с вещественными числами, например - имеет ли одна и то же выражение с одной и той же переменной одно и то же значение в разных частях программы, вроде ```x = 3.0/10.0; y = 10.0*x```, так же в статье подмечается, что в этом месте есть очень заметное отличие от системы аксиом Брауна системы IEEE, тем, что в IEEE мы можем доказать, что ```3.0/10.0 * 10.0``` - всегда будет 10.0. Так же, хотелось бы заметить, что в языках является очень тяжелой задачей - сделать систему вещественных вычислений, которая не зависит от расставления скобок. К примеру, пусть $ds$ имеет двойную точность, а $x, y$ - одинарную, какую в таком случае точность должно иметь выражение вида $ds + x * y$.

Так же у нас сразу возникают два варианта, как сделать вычисления точнее:
* вычислять все с максимальной точностью - но тогда у нас сильно вырастает потребление памяти, а так же увеличивается время исполнения каждой из инструкций в коде
* вычислять каждое выражение по переменной с максимальной точностью. Но в таком случае мы должны заранее знать все выражение, чтобы можно было составить его граф, а так же в выражениях где нужна точность хуже - делать ее хуже, чтобы оптимизировать наш код
И как видно, оба этих подхода не самые лучшие, но имеют место быть. Первый вариант, к слову, использовался в начальном стандарте C.

**Компиляторы и суммирование**

В компиляторах зачастую не регламентировано, как именно нужно взаимодействовать с выполнением операций с плавающей точкой. Но зачастую используется, что алгебраические правила взаимодействия со слагаемыми не должны влиять на итоговый результат, что в общем случае вещественной арифметики неправда. Так же, хочется заметить, что большинство компиляторов старается сохранять круглые скобки.

Как оптимизация вычисления суммы - предлагается [алгоритм суммирования Кэхэна](https://en.wikipedia.org/wiki/Kahan_summation_algorithm), он заключается в том, чтобы вычислять все в следующем порядке, ниже прикрепляю алгоритм и оценку ошибки.

<img width="552" alt="image" src="https://user-images.githubusercontent.com/76393917/197408779-a7dfef8e-a8c3-4bb9-a8bd-8f3e0b6d047d.png">

Так же, хочется отметить, что зачастую точность сильно теряется из-за взаимодействия между собой чисел разных порядков, из-за чего гораздо правильнее в большинстве случаев суммировать числа по возрастанию их модулей

**Как итог**

Многие языки и в принципе многие люди обходят стороной проблемы вещественных чисел, не считая их достаточно важной. Но авторы статьи с помощью математического языка показывают и доказывают, что для точного сложения и вычитания достаточно одиночной точности, рассматривают все возможные случаи - когда и при каких условиях результат выражения считается точно, а где с погрешностью, а так же с какой. Статья очень располагает к себе именно математической подоплекой и очевидными примерами, к сожалению из заинтересовавших меня вещей я смог прикрепить только алгоритм Кэхэна, но их в статье слишком много, чтобы уместить в отчет.
