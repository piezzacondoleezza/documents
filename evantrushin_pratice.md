Статья: https://docs.oracle.com/cd/E19957-01/800-7895/800-7895.pdf

**Ремарочка**
Сделаю небольшую ремарку, что в данном пересказе хотелось бы упомянть скорее о внутренних проблемах и интересных рассуждениях, а не о строении напрямую. Ибо практически каждый, кто ознакомлен с языками программирования - знаком со строением вещественных чисел в виде экспоненты, мантиссы и знака, знает о денормализованных числах, Nan, inf, знаковом нуле, и прочее. 


**Представление и проблемы вещественных чисел в различных языках**

Политика в отношении чисел с плавающей точкой ощутимо отличается в разных системах, и, соответственно, в разных языках:

Например - имеет ли одна и то же выражение с одной и той же переменной одно и то же значение во всех местах, где оно встречается, вроде ```x = 3.0/10.0; y = 10.0*x```, так же в статье подмечается, что в этом месте есть очень заметное отличие от системы аксиом Брауна системы IEEE, тем, что в IEEE мы можем доказать, что ```3.0/10.0 * 10.0``` - всегда будет 3.0, с помощью этой теоремы, доказательство которой приведено в статье:

<img width="609" alt="image" src="https://user-images.githubusercontent.com/76393917/197419315-b7a224d7-71d2-41ff-a305-8adaaa09b760.png">

Так же, хотелось бы заметить, что в языках является очень тяжелой задачей - сделать систему вещественных вычислений, которая не зависит от расставления скобок. К примеру, пусть $ds$ имеет двойную точность, а $x, y$ - одинарную, неочевидно какую в таком случае точность должно иметь выражение вида $ds + x * y$.

Так же у нас сразу возникают два варианта, как сделать вычисления точнее:
* вычислять все с максимальной точностью - но тогда у нас сильно вырастает потребление памяти, а так же увеличивается время исполнения каждой из инструкций в коде
* вычислять каждое выражение по переменной с максимальной точностью. Но в таком случае мы должны заранее знать все выражение, чтобы можно было составить его граф, а так же в выражениях где нужна точность хуже - делать ее хуже, чтобы оптимизировать наш код
И как видно, оба этих подхода не самые лучшие, но имеют место быть. Первый вариант, к слову, использовался в начальном стандарте языка C.

**Компиляторы и суммирование**

В компиляторах зачастую не регламентировано, как именно нужно взаимодействовать с выполнением операций с плавающей точкой. Но зачастую используется, что алгебраические правила взаимодействия со слагаемыми не должны влиять на итоговый результат, что в общем случае вещественной арифметики неправда. Так же, хочется заметить, что большинство компиляторов старается сохранять круглые скобки и приоритеты вычислений.

Как оптимизация вычисления суммы - предлагается [алгоритм суммирования Кэхэна](https://en.wikipedia.org/wiki/Kahan_summation_algorithm), он заключается в том, чтобы вычислять все в следующем порядке, ниже прикрепляю алгоритм и оценку ошибки.

<img width="552" alt="image" src="https://user-images.githubusercontent.com/76393917/197408779-a7dfef8e-a8c3-4bb9-a8bd-8f3e0b6d047d.png">
Интересно будет отметить, что зачастую современный компилятор может оптимизировать данный код и разворачивать его в простое вычисление в цикле - что нас не устраивает.

Так же, хочется отметить, что зачастую точность сильно теряется из-за взаимодействия между собой чисел разных порядков, из-за чего гораздо правильнее в большинстве случаев суммировать числа по возрастанию их модулей.

**Как итог**

Многие языки и в принципе многие люди обходят стороной проблемы вещественных чисел, не считая их достаточно важной. Но авторы статьи с помощью математического языка показывают и доказывают, что для точного сложения и вычитания достаточно одиночной точности, рассматривают все возможные случаи - когда и при каких условиях результат выражения считается точно, а где с погрешностью, а так же с какой. Статья очень располагает к себе именно математической подоплекой и очевидными примерами, к сожалению из заинтересовавших меня вещей я смог прикрепить только алгоритм Кэхэна, но их в статье слишком много, чтобы уместить в отчет.


